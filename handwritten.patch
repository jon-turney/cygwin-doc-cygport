diff -Naur inst.bak/usr/share/man/man3/sprintf.3 inst/usr/share/man/man3/sprintf.3
--- inst.bak/usr/share/man/man3/sprintf.3	2015-07-09 13:35:59.540206900 +0100
+++ inst/usr/share/man/man3/sprintf.3	2015-07-09 13:36:47.091985200 +0100
@@ -178,12 +178,12 @@
 .sp
 .TS
 allbox tab(:);
-l l
-l l
-l l
-l l
-l l
-l l.
+l l s
+l l s
+l l s
+l l s
+l l s
+l l s.
 T{
 \*(Aq
 T}:T{
@@ -265,51 +265,49 @@
 The result is to be converted to an alternative form, according to the
 \fItype\fR
 character:
+T}
 .sp
-.TS
-allbox tab(:);
-l l
-l l
-l l
-l l
-l l
-l l.
+.T&
+l l l
+l l l
+l l l
+l l l
+l l l
+l l l.
 T{
-<cell>o</cell>
 T}:T{
-<cell>Increases precision to force the first digit of the result to be a zero\&.</cell>
+o
+T}:T{
+Increases precision to force the first digit of the result to be a zero\&.
 T}
-T{
-<cell>x</cell>
+\^:T{
+x
 T}:T{
-<cell>A non\-zero result will have a
+A non\-zero result will have a
 0x
-prefix\&.</cell>
+prefix\&.
 T}
-T{
-<cell>X</cell>
+\^:T{
+X
 T}:T{
-<cell>A non\-zero result will have a
+A non\-zero result will have a
 0X
-prefix\&.</cell>
+prefix\&.
 T}
-T{
-<cell>a, A, e, E, f, or F</cell>
+\^:T{
+a, A, e, E, f, or F
 T}:T{
-<cell>The result will always contain a decimal point even if no digits follow the point\&. (Normally, a decimal point appears only if a digit follows it\&.) Trailing zeros are removed\&.</cell>
+The result will always contain a decimal point even if no digits follow the point\&. (Normally, a decimal point appears only if a digit follows it\&.) Trailing zeros are removed\&.
 T}
-T{
-<cell>g or G</cell>
+\^:T{
+g or G
 T}:T{
-<cell>The result will always contain a decimal point even if no digits follow the point\&. Trailing zeros are not removed\&.</cell>
+The result will always contain a decimal point even if no digits follow the point\&. Trailing zeros are not removed\&.
 T}
-T{
-<cell>all others</cell>
+\^:T{
+all others
 T}:T{
-<cell>Undefined\&.</cell>
-T}
-.TE
-.sp 1
+Undefined\&.
 T}
 .TE
 .sp 1
diff -Naur inst.bak/usr/share/man/man3/sscanf.3 inst/usr/share/man/man3/sscanf.3
--- inst.bak/usr/share/man/man3/sscanf.3	2015-07-09 13:35:59.524581000 +0100
+++ inst/usr/share/man/man3/sscanf.3	2015-07-09 13:38:44.716196500 +0100
@@ -125,10 +125,10 @@
 Each format specification begins with the percent character (%)\&. The other fields are:
 .TS
 allbox tab(:);
-l l
-l l
-l l
-l l.
+l l s
+l l s
+l l s
+l l s.
 T{
 *
 T}:T{
@@ -227,166 +227,167 @@
 scanf
 performs\&. Here is a table of the conversion characters:
 .PP
-.TS
-allbox tab(:);
-l l
-l l
-l l
-l l
-l l
-l l
-l l
-l l
-l l
-l l
-l l
-l l
-l l
-l l
-l l
-l l
-l l.
-T{
-<cell>%</cell>
+T}
+.T&
+l l l
+l l l
+l l l
+l l l
+l l l
+l l l
+l l l
+l l l
+l l l
+l l l
+l l l
+l l l
+l l l
+l l l
+l l l
+l l l
+l l l.
+\^:T{
+%
 T}:T{
-<cell>.PP
-No conversion is done; the percent character (%) is stored\&.</cell>
+.PP
+No conversion is done; the percent character (%) is stored\&.
 T}
-T{
-<cell>c</cell>
+\^:T{
+c
 T}:T{
-<cell>.PP
+.PP
 Scans one character\&. Corresponding
 \fIarg\fR:
-(char *arg)\&.</cell>
+(char *arg)\&.
 T}
-T{
-<cell>s</cell>
+\^:T{
+s
 T}:T{
-<cell>.PP
+.PP
 Reads a character string into the array supplied\&. Corresponding
 \fIarg\fR:
-(char arg[])\&.</cell>
+(char arg[])\&.
 T}
-T{
-<cell>[\fIpattern\fR]</cell>
+\^:T{
+[\fIpattern\fR]
 T}:T{
-<cell>.PP
+.PP
 Reads a non\-empty character string into memory starting at
 \fIarg\fR\&. This area must be large enough to accept the sequence and a terminating null character which will be added automatically\&. (\fIpattern\fR
 is discussed in the paragraph following this table)\&. Corresponding
 \fIarg\fR:
-(char *arg)\&.</cell>
+(char *arg)\&.
 T}
-T{
-<cell>d</cell>
+\^:T{
+d
 T}:T{
-<cell>.PP
+.PP
 Reads a decimal integer into the corresponding
 \fIarg\fR:
-(int *arg)\&.</cell>
+(int *arg)\&.
 T}
-T{
-<cell>D</cell>
+\^:T{
+D
 T}:T{
-<cell>.PP
+.PP
 Reads a decimal integer into the corresponding
 \fIarg\fR:
-(long *arg)\&.</cell>
+(long *arg)\&.
 T}
-T{
-<cell>o</cell>
+\^:T{
+o
 T}:T{
-<cell>.PP
+.PP
 Reads an octal integer into the corresponding
 \fIarg\fR:
-(int *arg)\&.</cell>
+(int *arg)\&.
 T}
-T{
-<cell>O</cell>
+\^:T{
+O
 T}:T{
-<cell>.PP
+.PP
 Reads an octal integer into the corresponding
 \fIarg\fR:
-(long *arg)\&.</cell>
+(long *arg)\&.
 T}
-T{
-<cell>u</cell>
+\^:T{
+u
 T}:T{
-<cell>.PP
+.PP
 Reads an unsigned decimal integer into the corresponding
 \fIarg\fR:
-(unsigned int *arg)\&.</cell>
+(unsigned int *arg)\&.
 T}
-T{
-<cell>U</cell>
+\^:T{
+U
 T}:T{
-<cell>.PP
+.PP
 Reads an unsigned decimal integer into the corresponding
 \fIarg\fR:
-(unsigned long *arg)\&.</cell>
+(unsigned long *arg)\&.
 T}
-T{
-<cell>x,X</cell>
+\^:T{
+x,X
 T}:T{
-<cell>.PP
+.PP
 Read a hexadecimal integer into the corresponding
 \fIarg\fR:
-(int *arg)\&.</cell>
+(int *arg)\&.
 T}
-T{
-<cell>e, f, g</cell>
+\^:T{
+e, f, g
 T}:T{
-<cell>.PP
+.PP
 Read a floating\-point number into the corresponding
 \fIarg\fR:
-(float *arg)\&.</cell>
+(float *arg)\&.
 T}
-T{
-<cell>E, F, G</cell>
+\^:T{
+E, F, G
 T}:T{
-<cell>.PP
+.PP
 Read a floating\-point number into the corresponding
 \fIarg\fR:
-(double *arg)\&.</cell>
+(double *arg)\&.
 T}
-T{
-<cell>i</cell>
+\^:T{
+i
 T}:T{
-<cell>.PP
+.PP
 Reads a decimal, octal or hexadecimal integer into the corresponding
 \fIarg\fR:
-(int *arg)\&.</cell>
+(int *arg)\&.
 T}
-T{
-<cell>I</cell>
+\^:T{
+I
 T}:T{
-<cell>.PP
+.PP
 Reads a decimal, octal or hexadecimal integer into the corresponding
 \fIarg\fR:
-(long *arg)\&.</cell>
+(long *arg)\&.
 T}
-T{
-<cell>n</cell>
+\^:T{
+n
 T}:T{
-<cell>.PP
+.PP
 Stores the number of characters read in the corresponding
 \fIarg\fR:
-(int *arg)\&.</cell>
+(int *arg)\&.
 T}
-T{
-<cell>p</cell>
+\^:T{
+p
 T}:T{
-<cell>.PP
+.PP
 Stores a scanned pointer\&. ANSI C leaves the details to each implementation; this implementation treats
 %p
 exactly the same as
 %U\&. Corresponding
 \fIarg\fR:
-(void **arg)\&.</cell>
+(void **arg)\&.
 T}
-.TE
-.sp 1
+.T&
+l l s.
+\^:T{
 A
 \fIpattern\fR
 of characters surrounded by square brackets can be used instead of the
@@ -402,36 +403,36 @@
 Here are some
 \fIpattern\fR
 examples:
-.TS
-allbox tab(:);
-l l
-l l
-l l
-l l.
-T{
-<cell>%[abcd]</cell>
+T}
+.T&
+l l l
+l l l
+l l l
+l l l.
+\^:T{
+%[abcd]
 T}:T{
-<cell>.PP
+.PP
 matches strings containing only
 a,
 b,
 c, and
-d\&.</cell>
+d\&.
 T}
-T{
-<cell>%[^abcd]</cell>
+\^:T{
+%[^abcd]
 T}:T{
-<cell>.PP
+.PP
 matches strings containing any characters except
 a,
 b,
 c, or
-d</cell>
+d
 T}
-T{
-<cell>%[A\-DW\-Z]</cell>
+\^:T{
+%[A\-DW\-Z]
 T}:T{
-<cell>.PP
+.PP
 matches strings containing
 A,
 B,
@@ -440,19 +441,20 @@
 W,
 X,
 Y,
-Z</cell>
+Z
 T}
-T{
-<cell>%[z\-a]</cell>
+\^:T{
+%[z\-a]
 T}:T{
-<cell>.PP
+.PP
 matches the characters
 z,
 \-, and
-a</cell>
+a
 T}
-.TE
-.sp 1
+.T&.
+l l s.
+\^:T{
 Floating point numbers (for field types
 e,
 f,
diff -Naur inst.bak/usr/share/man/man3/swprintf.3 inst/usr/share/man/man3/swprintf.3
--- inst.bak/usr/share/man/man3/swprintf.3	2015-07-09 13:35:59.524581000 +0100
+++ inst/usr/share/man/man3/swprintf.3	2015-07-09 13:42:32.268244400 +0100
@@ -153,12 +153,12 @@
 .sp
 .TS
 allbox tab(:);
-l l
-l l
-l l
-l l
-l l
-l l.
+l l s
+l l s
+l l s
+l l s
+l l s
+l l s.
 T{
 \*(Aq
 T}:T{
@@ -240,51 +240,49 @@
 The result is to be converted to an alternative form, according to the
 \fItype\fR
 character:
+T}
 .sp
-.TS
-allbox tab(:);
-l l
-l l
-l l
-l l
-l l
-l l.
+.T&
+l l l
+l l l
+l l l
+l l l
+l l l
+l l l.
 T{
-<cell>o</cell>
 T}:T{
-<cell>Increases precision to force the first digit of the result to be a zero\&.</cell>
+o
+T}:T{
+Increases precision to force the first digit of the result to be a zero\&.
 T}
-T{
-<cell>x</cell>
+\^:T{
+x
 T}:T{
-<cell>A non\-zero result will have a
+A non\-zero result will have a
 0x
-prefix\&.</cell>
+prefix\&.
 T}
-T{
-<cell>X</cell>
+\^:T{
+X
 T}:T{
-<cell>A non\-zero result will have a
+A non\-zero result will have a
 0X
-prefix\&.</cell>
+prefix\&.
 T}
-T{
-<cell>a, A, e, E, f, or F</cell>
+\^:T{
+a, A, e, E, f, or F
 T}:T{
-<cell>The result will always contain a decimal point even if no digits follow the point\&. (Normally, a decimal point appears only if a digit follows it\&.) Trailing zeros are removed\&.</cell>
+The result will always contain a decimal point even if no digits follow the point\&. (Normally, a decimal point appears only if a digit follows it\&.) Trailing zeros are removed\&.
 T}
-T{
-<cell>g or G</cell>
+\^:T{
+g or G
 T}:T{
-<cell>The result will always contain a decimal point even if no digits follow the point\&. Trailing zeros are not removed\&.</cell>
+The result will always contain a decimal point even if no digits follow the point\&. Trailing zeros are not removed\&.
 T}
-T{
-<cell>all others</cell>
+\^:T{
+all others
 T}:T{
-<cell>Undefined\&.</cell>
-T}
-.TE
-.sp 1
+Undefined\&.
 T}
 .TE
 .sp 1
diff -Naur inst.bak/usr/share/man/man3/swscanf.3 inst/usr/share/man/man3/swscanf.3
--- inst.bak/usr/share/man/man3/swscanf.3	2015-07-09 13:35:59.524581000 +0100
+++ inst/usr/share/man/man3/swscanf.3	2015-07-09 14:06:20.422084000 +0100
@@ -125,10 +125,10 @@
 Each format specification begins with the percent character (%)\&. The other fields are:
 .TS
 allbox tab(:);
-l l
-l l
-l l
-l l.
+l l s
+l l s
+l l s
+l l s.
 T{
 *
 T}:T{
@@ -227,31 +227,31 @@
 wscanf
 performs\&. Here is a table of the conversion characters:
 .PP
-.TS
-allbox tab(:);
-l l
-l l
-l l
-l l
-l l
-l l
-l l
-l l
-l l
-l l
-l l
-l l
-l l.
-T{
-<cell>%</cell>
+T}
+.T&
+l l l
+l l l
+l l l
+l l l
+l l l
+l l l
+l l l
+l l l
+l l l
+l l l
+l l l
+l l l
+l l l.
+\^:T{
+%
 T}:T{
-<cell>.PP
-No conversion is done; the percent character (%) is stored\&.</cell>
+.PP
+No conversion is done; the percent character (%) is stored\&.
 T}
-T{
-<cell>c</cell>
+\^:T{
+c
 T}:T{
-<cell>.PP
+.PP
 Scans one wide character\&. Corresponding
 \fIarg\fR:
 (char *arg)\&. Otherwise, if an
@@ -259,12 +259,12 @@
 specifier is present, the corresponding
 \fIarg\fR
 is a
-(wchar_t *arg)\&.</cell>
+(wchar_t *arg)\&.
 T}
-T{
-<cell>s</cell>
+\^:T{
+s
 T}:T{
-<cell>.PP
+.PP
 Reads a character string into the array supplied\&. Corresponding
 \fIarg\fR:
 (char arg[])\&. If an
@@ -272,12 +272,12 @@
 specifier is present, the corresponding
 \fIarg\fR
 is a
-(wchar_t *arg)\&.</cell>
+(wchar_t *arg)\&.
 T}
-T{
-<cell>[\fIpattern\fR]</cell>
+\^:T{
+[\fIpattern\fR]
 T}:T{
-<cell>.PP
+.PP
 Reads a non\-empty character string into memory starting at
 \fIarg\fR\&. This area must be large enough to accept the sequence and a terminating null character which will be added automatically\&. (\fIpattern\fR
 is discussed in the paragraph following this table)\&. Corresponding
@@ -287,85 +287,86 @@
 specifier is present, the corresponding
 \fIarg\fR
 is a
-(wchar_t *arg)\&.</cell>
+(wchar_t *arg)\&.
 T}
-T{
-<cell>d</cell>
+\^:T{
+d
 T}:T{
-<cell>.PP
+.PP
 Reads a decimal integer into the corresponding
 \fIarg\fR:
-(int *arg)\&.</cell>
+(int *arg)\&.
 T}
-T{
-<cell>o</cell>
+\^:T{
+o
 T}:T{
-<cell>.PP
+.PP
 Reads an octal integer into the corresponding
 \fIarg\fR:
-(int *arg)\&.</cell>
+(int *arg)\&.
 T}
-T{
-<cell>u</cell>
+\^:T{
+u
 T}:T{
-<cell>.PP
+.PP
 Reads an unsigned decimal integer into the corresponding
 \fIarg\fR:
-(unsigned int *arg)\&.</cell>
+(unsigned int *arg)\&.
 T}
-T{
-<cell>x,X</cell>
+\^:T{
+x,X
 T}:T{
-<cell>.PP
+.PP
 Read a hexadecimal integer into the corresponding
 \fIarg\fR:
-(int *arg)\&.</cell>
+(int *arg)\&.
 T}
-T{
-<cell>e, f, g</cell>
+\^:T{
+e, f, g
 T}:T{
-<cell>.PP
+.PP
 Read a floating\-point number into the corresponding
 \fIarg\fR:
-(float *arg)\&.</cell>
+(float *arg)\&.
 T}
-T{
-<cell>E, F, G</cell>
+\^:T{
+E, F, G
 T}:T{
-<cell>.PP
+.PP
 Read a floating\-point number into the corresponding
 \fIarg\fR:
-(double *arg)\&.</cell>
+(double *arg)\&.
 T}
-T{
-<cell>i</cell>
+\^:T{
+i
 T}:T{
-<cell>.PP
+.PP
 Reads a decimal, octal or hexadecimal integer into the corresponding
 \fIarg\fR:
-(int *arg)\&.</cell>
+(int *arg)\&.
 T}
-T{
-<cell>n</cell>
+\^:T{
+n
 T}:T{
-<cell>.PP
+.PP
 Stores the number of characters read in the corresponding
 \fIarg\fR:
-(int *arg)\&.</cell>
+(int *arg)\&.
 T}
-T{
-<cell>p</cell>
+\^:T{
+p
 T}:T{
-<cell>.PP
+.PP
 Stores a scanned pointer\&. ANSI C leaves the details to each implementation; this implementation treats
 %p
 exactly the same as
 %U\&. Corresponding
 \fIarg\fR:
-(void **arg)\&.</cell>
+(void **arg)\&.
 T}
-.TE
-.sp 1
+.T&
+l l s.
+\^:T{
 A
 \fIpattern\fR
 of characters surrounded by square brackets can be used instead of the
@@ -379,44 +380,43 @@
 Here are some
 \fIpattern\fR
 examples:
-.TS
-allbox tab(:);
-l l
-l l
-l l.
-T{
-<cell>%[abcd]</cell>
+T}
+.T&
+l l l.
+\^:T{
+%[abcd]
 T}:T{
-<cell>.PP
+.PP
 matches wide character strings containing only
 a,
 b,
 c, and
-d\&.</cell>
+d\&.
 T}
-T{
-<cell>%[^abcd]</cell>
+\^:T{
+%[^abcd]
 T}:T{
-<cell>.PP
+.PP
 matches wide character strings containing any characters except
 a,
 b,
 c, or
-d\&.</cell>
+d\&.
 T}
-T{
-<cell>%[A\-DW\-Z]</cell>
+\^:T{
+%[A\-DW\-Z]
 T}:T{
-<cell>.PP
+.PP
 Note: No wide character ranges, so this expression matches wide character strings containing
 A,
 \-,
 D,
 W,
-Z\&.</cell>
+Z\&.
 T}
-.TE
-.sp 1
+.T&
+l l s.
+\^:T{
 Floating point numbers (for field types
 e,
 f,
